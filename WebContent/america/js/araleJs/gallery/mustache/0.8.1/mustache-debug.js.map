{"version":3,"sources":["gallery/mustache/0.8.1/mustache-debug.js"],"names":["define","require","exports","root","factory","mustache","amd","Mustache","this","testRegExp","re","string","RegExp_test","call","isWhitespace","nonSpaceRe","isFunction","object","escapeRegExp","replace","escapeHtml","String","s","entityMap","escapeTags","tags","isArray","length","Error","RegExp","parseTemplate","template","stripSpace","hasTag","nonSpace","spaces","tokens","pop","split","spaceRe","start","type","value","chr","token","openSection","tagRes","scanner","Scanner","sections","eos","pos","scanUntil","i","len","charAt","push","scan","tagRe","whiteRe","eqRe","curlyRe","nestTokens","squashTokens","lastToken","squashedTokens","section","nestedTokens","collector","tail","Context","view","parentContext","cache",".","parent","Writer","prototype","test","Object_toString","Object","toString","Array","&","<",">","\"","'","/","match","index","substring","search","lookup","name","context","indexOf","names","clearCache","parse","render","partials","renderTokens","originalTemplate","subRender","self","buffer","j","jlen","slice","escape","version","defaultWriter","to_html","send","result"],"mappings":"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","file":"gallery/mustache/0.8.1/mustache-debug.js","sourcesContent":["define(\"gallery/mustache/0.8.1/mustache-debug\", [], function(require, exports, module) {\n    /*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n    /*global define: false*/\n    (function(root, factory) {\n        if (typeof exports === \"object\" && exports) {\n            factory(exports);\n        } else {\n            var mustache = {};\n            factory(mustache);\n            if (typeof define === \"function\" && define.amd) {\n                define(mustache);\n            } else {\n                root.Mustache = mustache;\n            }\n        }\n    })(this, function(mustache) {\n        var whiteRe = /\\s*/;\n        var spaceRe = /\\s+/;\n        var nonSpaceRe = /\\S/;\n        var eqRe = /\\s*=/;\n        var curlyRe = /\\s*\\}/;\n        var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n        // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n        // See https://github.com/janl/mustache.js/issues/189\n        var RegExp_test = RegExp.prototype.test;\n        function testRegExp(re, string) {\n            return RegExp_test.call(re, string);\n        }\n        function isWhitespace(string) {\n            return !testRegExp(nonSpaceRe, string);\n        }\n        var Object_toString = Object.prototype.toString;\n        var isArray = Array.isArray || function(object) {\n            return Object_toString.call(object) === \"[object Array]\";\n        };\n        function isFunction(object) {\n            return typeof object === \"function\";\n        }\n        function escapeRegExp(string) {\n            return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n        }\n        var entityMap = {\n            \"&\": \"&amp;\",\n            \"<\": \"&lt;\",\n            \">\": \"&gt;\",\n            '\"': \"&quot;\",\n            \"'\": \"&#39;\",\n            \"/\": \"&#x2F;\"\n        };\n        function escapeHtml(string) {\n            return String(string).replace(/[&<>\"'\\/]/g, function(s) {\n                return entityMap[s];\n            });\n        }\n        function escapeTags(tags) {\n            if (!isArray(tags) || tags.length !== 2) {\n                throw new Error(\"Invalid tags: \" + tags);\n            }\n            return [ new RegExp(escapeRegExp(tags[0]) + \"\\\\s*\"), new RegExp(\"\\\\s*\" + escapeRegExp(tags[1])) ];\n        }\n        /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all template text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices\n   * in the original template of the token, respectively.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: an\n   * array of tokens in the subtree and the index in the original template at which\n   * the closing tag for that section begins.\n   */\n        function parseTemplate(template, tags) {\n            tags = tags || mustache.tags;\n            template = template || \"\";\n            if (typeof tags === \"string\") {\n                tags = tags.split(spaceRe);\n            }\n            var tagRes = escapeTags(tags);\n            var scanner = new Scanner(template);\n            var sections = [];\n            // Stack to hold section tokens\n            var tokens = [];\n            // Buffer to hold the tokens\n            var spaces = [];\n            // Indices of whitespace tokens on the current line\n            var hasTag = false;\n            // Is there a {{tag}} on the current line?\n            var nonSpace = false;\n            // Is there a non-space char on the current line?\n            // Strips all whitespace tokens array for the current line\n            // if there was a {{#tag}} on it and otherwise only space.\n            function stripSpace() {\n                if (hasTag && !nonSpace) {\n                    while (spaces.length) {\n                        delete tokens[spaces.pop()];\n                    }\n                } else {\n                    spaces = [];\n                }\n                hasTag = false;\n                nonSpace = false;\n            }\n            var start, type, value, chr, token, openSection;\n            while (!scanner.eos()) {\n                start = scanner.pos;\n                // Match any text between tags.\n                value = scanner.scanUntil(tagRes[0]);\n                if (value) {\n                    for (var i = 0, len = value.length; i < len; ++i) {\n                        chr = value.charAt(i);\n                        if (isWhitespace(chr)) {\n                            spaces.push(tokens.length);\n                        } else {\n                            nonSpace = true;\n                        }\n                        tokens.push([ \"text\", chr, start, start + 1 ]);\n                        start += 1;\n                        // Check for whitespace on the current line.\n                        if (chr === \"\\n\") {\n                            stripSpace();\n                        }\n                    }\n                }\n                // Match the opening tag.\n                if (!scanner.scan(tagRes[0])) break;\n                hasTag = true;\n                // Get the tag type.\n                type = scanner.scan(tagRe) || \"name\";\n                scanner.scan(whiteRe);\n                // Get the tag value.\n                if (type === \"=\") {\n                    value = scanner.scanUntil(eqRe);\n                    scanner.scan(eqRe);\n                    scanner.scanUntil(tagRes[1]);\n                } else if (type === \"{\") {\n                    value = scanner.scanUntil(new RegExp(\"\\\\s*\" + escapeRegExp(\"}\" + tags[1])));\n                    scanner.scan(curlyRe);\n                    scanner.scanUntil(tagRes[1]);\n                    type = \"&\";\n                } else {\n                    value = scanner.scanUntil(tagRes[1]);\n                }\n                // Match the closing tag.\n                if (!scanner.scan(tagRes[1])) {\n                    throw new Error(\"Unclosed tag at \" + scanner.pos);\n                }\n                token = [ type, value, start, scanner.pos ];\n                tokens.push(token);\n                if (type === \"#\" || type === \"^\") {\n                    sections.push(token);\n                } else if (type === \"/\") {\n                    // Check section nesting.\n                    openSection = sections.pop();\n                    if (!openSection) {\n                        throw new Error('Unopened section \"' + value + '\" at ' + start);\n                    }\n                    if (openSection[1] !== value) {\n                        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n                    }\n                } else if (type === \"name\" || type === \"{\" || type === \"&\") {\n                    nonSpace = true;\n                } else if (type === \"=\") {\n                    // Set the tags for the next time around.\n                    tagRes = escapeTags(tags = value.split(spaceRe));\n                }\n            }\n            // Make sure there are no open sections when we're done.\n            openSection = sections.pop();\n            if (openSection) {\n                throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n            }\n            return nestTokens(squashTokens(tokens));\n        }\n        /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n        function squashTokens(tokens) {\n            var squashedTokens = [];\n            var token, lastToken;\n            for (var i = 0, len = tokens.length; i < len; ++i) {\n                token = tokens[i];\n                if (token) {\n                    if (token[0] === \"text\" && lastToken && lastToken[0] === \"text\") {\n                        lastToken[1] += token[1];\n                        lastToken[3] = token[3];\n                    } else {\n                        squashedTokens.push(token);\n                        lastToken = token;\n                    }\n                }\n            }\n            return squashedTokens;\n        }\n        /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n        function nestTokens(tokens) {\n            var nestedTokens = [];\n            var collector = nestedTokens;\n            var sections = [];\n            var token, section;\n            for (var i = 0, len = tokens.length; i < len; ++i) {\n                token = tokens[i];\n                switch (token[0]) {\n                  case \"#\":\n                  case \"^\":\n                    collector.push(token);\n                    sections.push(token);\n                    collector = token[4] = [];\n                    break;\n\n                  case \"/\":\n                    section = sections.pop();\n                    section[5] = token[2];\n                    collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n                    break;\n\n                  default:\n                    collector.push(token);\n                }\n            }\n            return nestedTokens;\n        }\n        /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n        function Scanner(string) {\n            this.string = string;\n            this.tail = string;\n            this.pos = 0;\n        }\n        /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n        Scanner.prototype.eos = function() {\n            return this.tail === \"\";\n        };\n        /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n        Scanner.prototype.scan = function(re) {\n            var match = this.tail.match(re);\n            if (match && match.index === 0) {\n                var string = match[0];\n                this.tail = this.tail.substring(string.length);\n                this.pos += string.length;\n                return string;\n            }\n            return \"\";\n        };\n        /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n        Scanner.prototype.scanUntil = function(re) {\n            var index = this.tail.search(re), match;\n            switch (index) {\n              case -1:\n                match = this.tail;\n                this.tail = \"\";\n                break;\n\n              case 0:\n                match = \"\";\n                break;\n\n              default:\n                match = this.tail.substring(0, index);\n                this.tail = this.tail.substring(index);\n            }\n            this.pos += match.length;\n            return match;\n        };\n        /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n        function Context(view, parentContext) {\n            this.view = view == null ? {} : view;\n            this.cache = {\n                \".\": this.view\n            };\n            this.parent = parentContext;\n        }\n        /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n        Context.prototype.push = function(view) {\n            return new Context(view, this);\n        };\n        /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n        Context.prototype.lookup = function(name) {\n            var value;\n            if (name in this.cache) {\n                value = this.cache[name];\n            } else {\n                var context = this;\n                while (context) {\n                    if (name.indexOf(\".\") > 0) {\n                        value = context.view;\n                        var names = name.split(\".\"), i = 0;\n                        while (value != null && i < names.length) {\n                            value = value[names[i++]];\n                        }\n                    } else {\n                        value = context.view[name];\n                    }\n                    if (value != null) break;\n                    context = context.parent;\n                }\n                this.cache[name] = value;\n            }\n            if (isFunction(value)) {\n                value = value.call(this.view);\n            }\n            return value;\n        };\n        /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n        function Writer() {\n            this.cache = {};\n        }\n        /**\n   * Clears all cached templates in this writer.\n   */\n        Writer.prototype.clearCache = function() {\n            this.cache = {};\n        };\n        /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n        Writer.prototype.parse = function(template, tags) {\n            var cache = this.cache;\n            var tokens = cache[template];\n            if (tokens == null) {\n                tokens = cache[template] = parseTemplate(template, tags);\n            }\n            return tokens;\n        };\n        /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n        Writer.prototype.render = function(template, view, partials) {\n            var tokens = this.parse(template);\n            var context = view instanceof Context ? view : new Context(view);\n            return this.renderTokens(tokens, context, partials, template);\n        };\n        /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n        Writer.prototype.renderTokens = function(tokens, context, partials, originalTemplate) {\n            var buffer = \"\";\n            // This function is used to render an arbitrary template\n            // in the current context by higher-order sections.\n            var self = this;\n            function subRender(template) {\n                return self.render(template, context, partials);\n            }\n            var token, value;\n            for (var i = 0, len = tokens.length; i < len; ++i) {\n                token = tokens[i];\n                switch (token[0]) {\n                  case \"#\":\n                    value = context.lookup(token[1]);\n                    if (!value) continue;\n                    if (isArray(value)) {\n                        for (var j = 0, jlen = value.length; j < jlen; ++j) {\n                            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n                        }\n                    } else if (typeof value === \"object\" || typeof value === \"string\") {\n                        buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n                    } else if (isFunction(value)) {\n                        if (typeof originalTemplate !== \"string\") {\n                            throw new Error(\"Cannot use higher-order sections without the original template\");\n                        }\n                        // Extract the portion of the original template that the section contains.\n                        value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n                        if (value != null) buffer += value;\n                    } else {\n                        buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n                    }\n                    break;\n\n                  case \"^\":\n                    value = context.lookup(token[1]);\n                    // Use JavaScript's definition of falsy. Include empty arrays.\n                    // See https://github.com/janl/mustache.js/issues/186\n                    if (!value || isArray(value) && value.length === 0) {\n                        buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n                    }\n                    break;\n\n                  case \">\":\n                    if (!partials) continue;\n                    value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n                    if (value != null) buffer += this.renderTokens(this.parse(value), context, partials, value);\n                    break;\n\n                  case \"&\":\n                    value = context.lookup(token[1]);\n                    if (value != null) buffer += value;\n                    break;\n\n                  case \"name\":\n                    value = context.lookup(token[1]);\n                    if (value != null) buffer += mustache.escape(value);\n                    break;\n\n                  case \"text\":\n                    buffer += token[1];\n                    break;\n                }\n            }\n            return buffer;\n        };\n        mustache.name = \"mustache.js\";\n        mustache.version = \"0.8.1\";\n        mustache.tags = [ \"{{\", \"}}\" ];\n        // All high-level mustache.* functions use this writer.\n        var defaultWriter = new Writer();\n        /**\n   * Clears all cached templates in the default writer.\n   */\n        mustache.clearCache = function() {\n            return defaultWriter.clearCache();\n        };\n        /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n        mustache.parse = function(template, tags) {\n            return defaultWriter.parse(template, tags);\n        };\n        /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n        mustache.render = function(template, view, partials) {\n            return defaultWriter.render(template, view, partials);\n        };\n        // This is here for backwards compatibility with 0.4.x.\n        mustache.to_html = function(template, view, partials, send) {\n            var result = mustache.render(template, view, partials);\n            if (isFunction(send)) {\n                send(result);\n            } else {\n                return result;\n            }\n        };\n        // Export the escaping function so that the user may override it.\n        // See https://github.com/janl/mustache.js/issues/244\n        mustache.escape = escapeHtml;\n        // Export these mainly for testing, but also for advanced usage.\n        mustache.Scanner = Scanner;\n        mustache.Context = Context;\n        mustache.Writer = Writer;\n    });\n});\n"],"sourceRoot":"/source/"}